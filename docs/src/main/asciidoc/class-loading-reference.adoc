////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Quarkus - Class Loading Reference

include::./attributes.adoc[]

This document explains the Quarkus class loading architecture. It is intended for extension
authors and advanced users who want to understand exactly how Quarkus works.

The Quarkus class loading architecture is slightly different depending on the mode that
the application is run in. When running a production application everything is loaded
in the system class loader, so it is a completely flat class path. This also applies to
native image mode which does not really support multiple class loaders, and is based on
a normal production Quarkus application.

For all other use cases (e.g. tests, dev mode, and building the application) Quarkus
uses the class loading architecture outlined here.

== Bootstrapping Quarkus

All Quarkus applications are created by the QuarkusBootstrap class in the `independent-projects/bootstrap` module. This
class is used to resolve all the relevant dependencies (both deployment and runtime) that are needed for the Quarkus
application. The end result of this process is a `CuratedApplication`, which contains all the class loading information
for the application.


== Isolated Class Loaders

The runtime class loader is always isolated. This means that it will have it's own copies of almost every class from the
resolved dependency list. The exception to this are:

- JDK classes
- Classes from artifacts that extensions have marked as parent first (more on this later).

=== Parent First Dependencies

There are some classes that should not be loaded in an isolated manner, but that should always be loaded by the system
class loader (or whatever class loader is responsible for bootstrapping Quarkus). Most extensions do not need to worry about
this, however there are a few cases where this is necessary:

- Some logging related classes, as logging must be loaded by the system class loader
- Quarkus bootstrap itself

If this is required it can be configured in the `quarkus-bootstrap-maven-plugin`. Note that if you
mark a dependency as parent first then all of it's dependencies must also be parent first,
or a `LinkageError` can occur.

[source,xml]
----
<plugin>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-bootstrap-maven-plugin</artifactId>
    <configuration>
        <parentFirstArtifacts>
            <parentFirstArtifact>io.quarkus:quarkus-bootstrap-core</parentFirstArtifact>
            <parentFirstArtifact>io.quarkus:quarkus-development-mode-spi</parentFirstArtifact>
            <parentFirstArtifact>org.jboss.logmanager:jboss-logmanager-embedded</parentFirstArtifact>
            <parentFirstArtifact>org.jboss.logging:jboss-logging</parentFirstArtifact>
            <parentFirstArtifact>org.ow2.asm:asm</parentFirstArtifact>
        </parentFirstArtifacts>
    </configuration>
</plugin>
----

=== Banned Dependencies

There are some dependencies that we can be sure we do not want. This generally happens when a dependency has had a name
change (e.g. smallrye-config changing groups from `org.smallrye` to `org.smallrye.config`, the `javax` -> `jakarta` rename).
This can cause problems, as if these artifacts end up in the dependency tree out of date classes can be loaded that are
not compatible with Quarkus. To deal with this this extensions can specify artifacts that should never be loaded. This is
done by modifying the `quarkus-bootstrap-maven-plugin` config in the pom (which generates the `quarkus-extension.properties`
file). Simply add an `excludedArtifacts` section as shown below:

[source,xml]
----
<plugin>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-bootstrap-maven-plugin</artifactId>
    <configuration>
        <excludedArtifacts>
            <excludedArtifact>io.smallrye:smallrye-config</excludedArtifact>
            <excludedArtifact>javax.enterprise:cdi-api</excludedArtifact>
        </excludedArtifacts>
    </configuration>
</plugin>
----

This should only be done if the extension depends on a never version of these artifacts. If the extension does not bring
in a replacement artifact as a dependency then classes the application needs might end up missing.