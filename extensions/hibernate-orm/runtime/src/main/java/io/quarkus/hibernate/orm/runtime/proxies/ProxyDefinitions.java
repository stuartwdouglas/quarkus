package io.quarkus.hibernate.orm.runtime.proxies;

import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;

/**
 * Runtime proxies are used by Hibernate ORM to handle a number of corner cases;
 * in particular Enhanced Proxies need special consideration in Quarkus as
 * they aren't generated by the enhancers during the build.
 * Since we can't generate new class definitions at runtime, this value holder
 * class is meant to be created at build time and hold onto those class definitions.
 *
 * Implementors of a custom {@link org.hibernate.bytecode.spi.ProxyFactoryFactory} are
 * then able to lookup such class definitions at runtime to create new instances of the
 * required enhanced proxies.
 *
 * Failure to generate such a proxy is not critical, but it implies that Hibernate ORM
 * will not be able to use the enhanced proxy mechanism, possibly having to generate
 * an additional round trip to the database in some circumstances.
 * Most notably we'll fail to generate such a proxy when the entity has a "final" modifier;
 * we'll also need a default constructor.
 * Default constructors are required beyond proxy generation, so a lack of such a constructor
 * will have us abort the bootstrap process with a critical error.
 * On the other hand, having the entities marked as "final" is handled gracefully, as we
 * can simply fallback to not use the enhanced proxy for the specific entity, and because
 * it's a common case when writing entities in Kotlin.
 */
public final class ProxyDefinitions {

    private Map<Class<?>, ProxyClassDetailsHolder> proxyDefinitionMap;

    public ProxyDefinitions() {
        this.proxyDefinitionMap = new HashMap<>();
    }

    public Map<Class<?>, ProxyClassDetailsHolder> getProxyDefinitionMap() {
        return proxyDefinitionMap;
    }

    public void setProxyDefinitionMap(Map<Class<?>, ProxyClassDetailsHolder> proxyDefinitionMap) {
        this.proxyDefinitionMap = proxyDefinitionMap;
    }

    public ProxyClassDetailsHolder getProxyForClass(Class persistentClass) {
        return proxyDefinitionMap.get(persistentClass);
    }

    public static class ProxyClassDetailsHolder {

        private boolean overridesEquals;
        private String className;
        private Constructor constructor;

        public ProxyClassDetailsHolder() {

        }

        public ProxyClassDetailsHolder(boolean overridesEquals, String className) {
            this.overridesEquals = overridesEquals;
            this.className = className;
        }

        public void setOverridesEquals(boolean overridesEquals) {
            this.overridesEquals = overridesEquals;
        }

        public String getClassName() {
            return className;
        }

        public void setClassName(String className) {
            this.className = className;
        }

        public boolean isOverridesEquals() {
            return overridesEquals;
        }

        public Constructor getConstructor() {
            if (constructor == null) {
                try {
                    constructor = Class.forName(className, false, Thread.currentThread().getContextClassLoader())
                            .getConstructor();
                } catch (ClassNotFoundException | NoSuchMethodException e) {
                    throw new RuntimeException(e);
                }
            }
            return constructor;
        }

    }

}
